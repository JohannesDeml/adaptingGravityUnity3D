// --------------------------------------------------------------------------------------------------------------------
// <copyright file="GravityHandler.cs" company="Johannes Deml">
//   Copyright (c) 2015 Johannes Deml. All rights reserved.
// </copyright>
// <author>
//   Johannes Deml
//   send@johannesdeml.com
// </author>
// --------------------------------------------------------------------------------------------------------------------

namespace AdaptingGravity.Physics.Gravity
{
    using System.Linq;
    using UnityEngine;
    using System.Collections.Generic;

    /// <summary>
    /// The gravity handler is the heart piece of the adapting gravity system. It controls the gravity handles (<see cref="GravityHandle"/>)
    /// and stores information about the current state of gravity
    /// </summary>
    [RequireComponent(typeof(Rigidbody))]
    public class GravityHandler : MonoBehaviour
    {
        public delegate void GravityEventDelegate(Vector3 gravityDirection);
        public event GravityEventDelegate GravityChanged; // This event is thrown whenever there is a change of the gravity direction
        public bool OnGround { get; private set; } // True if the player touches an attracting object, otherwise false
        public Vector3 GroundNormal { get; private set; } // The last evaluated nearest face normal, that is also the negative gravity direction
        [Tooltip("Tags of game objects that can alter the gravity direction")]
        public string[] attractingObjectTags = new string[] {"Ground"};
        [Tooltip("The strength of gravity in meters per second², earths gravity is 9.80665 m/s²")]
        public float gravityStrength = 15f;
        [Tooltip("The length of the rays that is used to check for attracting objects")]
        public float gravityCheckDistance = 5f;
        [Tooltip("The distance that defines whether or not an object is on the ground")]
        public float groundCheckDistance = 0.1f;
        [Tooltip("If true all faces that the gravity handles evaluated are summed up and averaged to get the new gravity direction")]
        public bool UseAverageGravityDirection = false;
        public GameObject GravityHandles;
        public GameObject GravityHandlePrefab;
        [Tooltip("Those are the handles the gravity uses to dertermine where the gravity should point at. They are child objects and can be generated by clicking on 'Add Handle'")]
        public List<GravityHandle> handles;

        private Vector3 gravityDirection = Vector3.down; // The current gravity direction the player experiences
        public float groundDistance { get; private set; } // The nearest distance to the ground that is evaluated through the gravity handles rays

        private new Rigidbody rigidbody;
    
        void Awake ()
        {
            groundDistance = 0f;
            rigidbody = GetComponent<Rigidbody>();
            GroundNormal = Vector3.up;
        }
	
        /// <summary>
        /// Every Fixed Update the gravity handles are evaluated and the gravity is applied to the player, unless the gravity strength is too small
        /// </summary>
        void FixedUpdate () {
            if (UseAverageGravityDirection)
            {
                CalculateAverageGravityDirection();
            }
            else
            {
                CalculateGravityDirection();
            }
            
            if (Mathf.Abs(gravityStrength) > 0.02f)
            {
                rigidbody.AddForce(gravityDirection * gravityStrength, ForceMode.Force);
            }
        }
        /// <summary>
        /// Runs through all gravity handles and searches for the nearest face that is hit by a handle ray. 
        /// The normal of this face is used for the new GroundNormal.
        /// </summary>
        void CalculateGravityDirection()
        {
            GravityHandle nearestHandle = null;
            float nearestGroundDistance = float.MaxValue;
            foreach (GravityHandle gravityHandle in handles)
            {
                if (gravityHandle.CalculateGravityDirection())
                {
                    if (gravityHandle.GroundDistance < nearestGroundDistance)
                    {
                        nearestGroundDistance = gravityHandle.GroundDistance;
                        nearestHandle = gravityHandle;
                    }
                }
            }
            if (nearestHandle != null)
            {
                nearestHandle.IsActiveGravityDirection = true;
                ApplyNewGroundNormal(nearestHandle.GroundNormal);
            }
        }

        /// <summary>
        /// Runs through all gravity handles and stores all faces that where hit by the rays.
        /// Then an average is taken from those face normals which is used as a new GroundNormal.
        /// </summary>
        void CalculateAverageGravityDirection()
        {
            float sumGroundDistance = 0f;
            Vector3 sumGroundNormals = Vector3.zero;
            foreach (GravityHandle gravityHandle in handles)
            {
                if (gravityHandle.CalculateGravityDirection())
                {
                    //float weight = (groundCheckDistance - gravityHandle.GroundDistance)/groundCheckDistance; creates strange osciliation
                    float weight = 1f;
                    sumGroundDistance += weight;
                    sumGroundNormals += gravityHandle.GroundNormal*weight;
                    gravityHandle.IsActiveGravityDirection = true;
                }
            }
            Vector3 newGroundNormal = sumGroundNormals/sumGroundDistance;
            Debug.DrawLine(transform.position, transform.position + newGroundNormal * 3f, Color.red);
            ApplyNewGroundNormal(newGroundNormal);
        }

        /// <summary>
        /// Calculates the new gravity direction and send out an GravityChanged event if the new gravity direction differs from the old one.
        /// </summary>
        /// <param name="newGroundNormal">The negative ground normal is used to set the new gravity direction</param>
        private void ApplyNewGroundNormal(Vector3 newGroundNormal)
        {
            if (GroundNormal != newGroundNormal)
            {
                GroundNormal = Vector3.Lerp(GroundNormal, newGroundNormal, 2f * Time.fixedDeltaTime);
                gravityDirection = -GroundNormal;
                if (GravityChanged != null)
                {
                    GravityChanged(gravityDirection);
                }
            }
        }

        /// <summary>
        /// Changes the gravity strength. 
        /// The strength of gravity in meters per second², earths gravity is 9.80665 m/s²
        /// </summary>
        /// <param name="newGravity">If the float is smaller than 0.02 it will ge ignored, a value of around 15 worked rather well in the tests</param>
        public void ChangeGravityStrength(float newGravity)
        {
            gravityStrength = newGravity;
        }

        /// <summary>
        /// Searches for a GravityHandles object and creates one if there is none.
        /// For more information about the functionality of Reset take a look at http://docs.unity3d.com/ScriptReference/MonoBehaviour.Reset.html
        /// </summary>
        private void Reset()
        {
            if (GravityHandles == null)
            {
                if (transform.FindChild("GravityHandles") != null)
                {
                    GravityHandles = transform.FindChild("GravityHandles").gameObject;
                }
                else
                {
                    GravityHandles = new GameObject("GravityHandles");
                    GravityHandles.transform.SetParent(transform, false);
                }
            }
        }


    }
}
